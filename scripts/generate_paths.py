#!/usr/bin/env python3

import argparse
import re
from pathlib import Path

# openapi3-parser
from openapi_parser import parse
from jinja2 import Template

template_code = """\
# Auto-generated by {{ script_name }}
# This file is generated from an OpenAPI specification.
# Any changes made directly to this file will be lost.

from .compat.enum import StrEnum

{% for group_name, group in groups.items() %}
class {{ group_name }}(StrEnum):
    {%- for name, value in group.items() %}
    {{ name }} = '{{ value }}'
    {%- endfor %}
{% endfor %}
"""


def enum_name(path_parts: list):
    """
    Generate a name for the enum based on the group name and endpoint.
    """
    group_name = path_parts[0].capitalize()
    if len(path_parts) == 1:
        return group_name, group_name.upper()

    name_parts = []
    for ix, part in enumerate(path_parts[1:], start=1):
        if part.startswith('{'):
            if len(name_parts) == 0:
                name_parts.append(group_name)
            name_parts[-1] = name_parts[-1].rstrip('s')
        else:
            name_parts.append(part.capitalize())

    name = '_'.join(name_parts).upper()
    name = re.sub(r'\W|^(?=\d)', '_', name)
    return group_name, name


def get_args():
    """
    Get the arguments from the command line.
    """
    default_input = Path('./openapi.yaml')
    default_output = Path('./paths_gen.py')
    parser = argparse.ArgumentParser(description='Generate Python Enums from OpenAPI paths.',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-i',
                        '--input',
                        required=True,
                        type=Path,
                        help='Input OpenAPI file path.',
                        default=default_input)
    parser.add_argument('-o',
                        '--output',
                        required=True,
                        type=Path,
                        help='Output file path for generated Enums.',
                        default=default_output)
    return parser.parse_args()


if __name__ == '__main__':
    args = get_args()

    specification = parse(str(args.input))
    paths = [p.url for p in specification.paths]

    grouped_paths = {}
    for path in paths:
        # As there is a leading slash in the path, the first element will be ''
        path_parts = path.split('/')[1:]
        group_name, path_name = enum_name(path_parts)
        if group_name not in grouped_paths:
            grouped_paths[group_name] = {}
        grouped_paths[group_name][path_name] = path

    template = Template(template_code)
    rendered_code = template.render(script_name=Path(__file__).name, groups=grouped_paths)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(rendered_code)
